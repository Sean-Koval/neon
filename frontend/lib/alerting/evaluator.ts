/**
 * Alert Evaluator
 *
 * Evaluates metric data against alert rules and manages alert state transitions.
 * Tracks alert state in-memory with support for configurable evaluation intervals.
 */

import type {
  AlertNotification,
  AlertRule,
  AlertState,
  AlertStateStatus,
  MetricDataPoint,
} from './types'

/**
 * Compares a metric value against a threshold using the specified operator.
 */
function evaluateCondition(
  value: number,
  operator: AlertRule['operator'],
  threshold: number,
): boolean {
  switch (operator) {
    case 'gt':
      return value > threshold
    case 'gte':
      return value >= threshold
    case 'lt':
      return value < threshold
    case 'lte':
      return value <= threshold
    case 'eq':
      return value === threshold
    default:
      return false
  }
}

export class AlertEvaluator {
  private rules: Map<string, AlertRule> = new Map()
  private states: Map<string, AlertState> = new Map()
  private notifications: AlertNotification[] = []

  constructor(rules: AlertRule[] = []) {
    for (const rule of rules) {
      this.addRule(rule)
    }
  }

  /** Add or update an alert rule */
  addRule(rule: AlertRule): void {
    this.rules.set(rule.id, rule)
    if (!this.states.has(rule.id)) {
      this.states.set(rule.id, {
        ruleId: rule.id,
        status: 'inactive',
        firedAt: null,
        resolvedAt: null,
        lastEvaluatedAt: new Date().toISOString(),
        currentValue: null,
        firingCount: 0,
      })
    }
  }

  /** Remove an alert rule and its state */
  removeRule(ruleId: string): boolean {
    this.states.delete(ruleId)
    return this.rules.delete(ruleId)
  }

  /** Get all registered rules */
  getRules(): AlertRule[] {
    return Array.from(this.rules.values())
  }

  /** Get a specific rule by ID */
  getRule(ruleId: string): AlertRule | undefined {
    return this.rules.get(ruleId)
  }

  /** Get the current state for a rule */
  getState(ruleId: string): AlertState | undefined {
    return this.states.get(ruleId)
  }

  /** Get all alert states */
  getAllStates(): AlertState[] {
    return Array.from(this.states.values())
  }

  /** Get only firing alerts */
  getFiringAlerts(): AlertState[] {
    return this.getAllStates().filter((s) => s.status === 'firing')
  }

  /** Get all notifications generated since last drain */
  drainNotifications(): AlertNotification[] {
    const notifications = [...this.notifications]
    this.notifications = []
    return notifications
  }

  /**
   * Evaluate a set of metric data points against all enabled rules.
   * Returns any new notifications generated by state transitions.
   */
  evaluate(metrics: MetricDataPoint[]): AlertNotification[] {
    const newNotifications: AlertNotification[] = []
    const now = new Date().toISOString()

    for (const rule of this.rules.values()) {
      if (!rule.enabled) continue

      // Find matching metrics for this rule
      const relevantMetrics = metrics.filter((m) => m.metric === rule.metric)

      const state = this.states.get(rule.id)
      if (!state) continue

      // Update evaluation timestamp
      state.lastEvaluatedAt = now

      if (relevantMetrics.length === 0) {
        // No data for this metric - keep current state
        continue
      }

      // Use the latest metric value
      const latestMetric = relevantMetrics[relevantMetrics.length - 1]
      state.currentValue = latestMetric.value

      const breaching = evaluateCondition(
        latestMetric.value,
        rule.operator,
        rule.threshold,
      )

      if (breaching) {
        state.firingCount++
      } else {
        // Reset consecutive breaches when condition is not met
        const wasFiring = state.status === 'firing'
        state.firingCount = 0

        if (wasFiring) {
          // Transition from firing to resolved
          state.status = 'resolved'
          state.resolvedAt = now

          const notification: AlertNotification = {
            rule,
            state: { ...state },
            type: 'resolved',
            timestamp: now,
          }
          newNotifications.push(notification)
          this.notifications.push(notification)
        } else if (state.status === 'pending') {
          // Was pending but didn't reach threshold - back to inactive
          state.status = 'inactive'
        }
        continue
      }

      // Check if consecutive breach threshold is met
      if (state.firingCount >= rule.consecutiveBreaches) {
        const previousStatus = state.status

        if (previousStatus !== 'firing') {
          // Transition to firing
          state.status = 'firing'
          state.firedAt = now

          const notification: AlertNotification = {
            rule,
            state: { ...state },
            type: 'firing',
            timestamp: now,
          }
          newNotifications.push(notification)
          this.notifications.push(notification)
        }
        // Already firing - no new notification
      } else {
        // Breaching but not yet at consecutive threshold
        if (state.status !== 'firing') {
          state.status = 'pending'
        }
      }
    }

    return newNotifications
  }

  /** Reset all alert states */
  reset(): void {
    for (const state of this.states.values()) {
      state.status = 'inactive'
      state.firedAt = null
      state.resolvedAt = null
      state.currentValue = null
      state.firingCount = 0
      state.lastEvaluatedAt = new Date().toISOString()
    }
    this.notifications = []
  }
}
